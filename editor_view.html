<!DOCTYPE html>
<html>

<head>
    <title>skarf.js - Track Three.js Scene</title>
    <meta charset="UTF-8" />

    <link href='http://fonts.googleapis.com/css?family=Fauna+One' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="css/style.css">

    <!--load helper libraries-->
    <script type="text/javascript" src="js/jquery/jquery-2.0.2.min.js"></script>

    <!--load 3D libraries-->
    <script type="text/javascript" src="js/threejs/three.min.js"></script>

    <!--load AR libraries-->
    <script type="text/javascript" src="js/js-aruco/svd.js"></script>
    <script type="text/javascript" src="js/js-aruco/posit1.js"></script>
    <script type="text/javascript" src="js/js-aruco/cv.js"></script>
    <script type="text/javascript" src="js/js-aruco/aruco.js"></script>

    <script>
    var video, canvas, context, imageData, detector, posit;
    var scene, renderer, camera, model, texture;
    var step = 0.0;
    var modelSize = 35.0; //millimeters
    var updateScene; //Function
    var map = {};
    
    function onLoad(){
      video = document.getElementById("video");
      canvas = document.getElementById("canvas");
      context = canvas.getContext("2d");
    
      canvas.width = parseInt(canvas.style.width);
      canvas.height = parseInt(canvas.style.height);
      
      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
      if (navigator.getUserMedia){
        init();
      }
    };
    
    function init(){
      navigator.getUserMedia({video:true}, 
        function (stream){
          if (window.webkitURL) {
            video.src = window.webkitURL.createObjectURL(stream);
          } else if (video.mozSrcObject !== undefined) {
            video.mozSrcObject = stream;
          } else {
            video.src = stream;
          }
        },
        function(error){
        }
      );
      
      detector = new AR.Detector();
      posit = new POS.Posit(modelSize, canvas.width);

      createRenderer();
      createScenes();

      requestAnimationFrame(tick);
    };
	
	function createRenderer(){
      renderer = new THREE.WebGLRenderer();
      renderer.setClearColor(0xffff00, 1);
      renderer.setSize(canvas.width, canvas.height);
      document.getElementById("container").appendChild(renderer.domElement);
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(40, canvas.width / canvas.height, 1, 1000);
      scene.add(camera);

      // directional lighting
      var directionalLight = new THREE.DirectionalLight(0xffffff);
      directionalLight.position.set(1, 1, 1).normalize();
      scene.add(directionalLight);
    };
    
    function snapshot(){
      context.drawImage(video, 0, 0, canvas.width, canvas.height);
      imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    };
    
    function drawCorners(markers){
      var corners, corner, i, j;
    
      context.lineWidth = 3;

      for (i = 0; i < markers.length; ++ i){
        corners = markers[i].corners;
        
        context.strokeStyle = "red";
        context.beginPath();
        
        for (j = 0; j < corners.length; ++ j){
          corner = corners[j];
          context.moveTo(corner.x, corner.y);
          corner = corners[(j + 1) % corners.length];
          context.lineTo(corner.x, corner.y);
        }

        context.stroke();
        context.closePath();
        
        context.strokeStyle = "green";
        context.strokeRect(corners[0].x - 2, corners[0].y - 2, 4, 4);
      }
    };
    
    function render(){
      renderer.autoClear = false;
      renderer.clear();
      renderer.render(scene, camera);
    };
    
    function createScenes(){
      texture = createTexture();
      scene.add(texture);
      //model = createModel();
      //scene.add(model);
    };
    
    function createTexture(){
      var texture = new THREE.Texture(video),
          object = new THREE.Object3D(),
          geometry = new THREE.PlaneGeometry(1.0, 1.0, 0.0),
          material = new THREE.MeshBasicMaterial( {map: texture, depthTest: false, depthWrite: false} ),
          mesh = new THREE.Mesh(geometry, material);
      
      object.position.z = -1;
      
      object.add(mesh);
      
      return object;
    };
    
    function createModel(name){
      var object = new THREE.Object3D();
      var mesh;
      var loader = new THREE.JSONLoader();
      loader.load("./models/"+name+"/"+name+".js", function (geometry, materials) {
            mesh = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial( materials ));
            object.add(mesh);
            mesh.scale.set( 0.5, 0.5, 0.5 );
        }, "models/"+name+"/");
      return object;
    };
    
    updateScene = function(markers){
      /*var corners, corner, pose, i;
      
      if (markers.length > 0){
        corners = markers[0].corners;
        
        for (i = 0; i < corners.length; ++ i){
          corner = corners[i];
          
          corner.x = corner.x - (canvas.width / 2);
          corner.y = (canvas.height / 2) - corner.y;
        }
        
        pose = posit.pose(corners);
        
        updateObject(model, pose.bestRotation, pose.bestTranslation);

        //updatePose("pose1", pose.bestError, pose.bestRotation, pose.bestTranslation);
        //updatePose("pose2", pose.alternativeError, pose.alternativeRotation, pose.alternativeTranslation);
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        //step += 0.025;
        
        //model.rotation.z -= step;
        $.getScript("my_lovely_script.js", function(){

            alert("Script loaded and executed.");

            // Use anything defined in the loaded script...
        });
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      }*/
      for(var m=0;m<markers.length;++m)
      	console.log("marker",markers[m].id);
      texture.children[0].material.map.needsUpdate = true;
    };
    
    function updateObject(object, rotation, translation){
      object.scale.x = modelSize;
      object.scale.y = modelSize;
      object.scale.z = modelSize;
      
      object.rotation.x = -Math.asin(-rotation[1][2]);
      object.rotation.y = -Math.atan2(rotation[0][2], rotation[2][2]);
      object.rotation.z = Math.atan2(rotation[1][0], rotation[1][1]);

      object.position.x = translation[0];
      object.position.y = translation[1];
      object.position.z = -translation[2];
    };
    
     function updatePose(id, error, rotation, translation){
      var yaw = -Math.atan2(rotation[0][2], rotation[2][2]);
      var pitch = -Math.asin(-rotation[1][2]);
      var roll = Math.atan2(rotation[1][0], rotation[1][1]);
      
      var d = document.getElementById(id);
      d.innerHTML = " error: " + error
                  + "<br/>"
                  + " x: " + (translation[0] | 0)
                  + " y: " + (translation[1] | 0)
                  + " z: " + (translation[2] | 0)
                  + "<br/>"
                  + " yaw: " + Math.round(-yaw * 180.0/Math.PI)
                  + " pitch: " + Math.round(-pitch * 180.0/Math.PI)
                  + " roll: " + Math.round(roll * 180.0/Math.PI);
    };
    
    function tick(){
      requestAnimationFrame(tick);
      
      if (video.readyState === video.HAVE_ENOUGH_DATA){
        snapshot();

        var markers = detector.detect(imageData);
        //drawCorners(markers);
        updateScene(markers);
        
        render();
      }
    };
    
    window.onload = onLoad;
    
    /*******************************************************/
    /*function checkWebGl() {
         if (!Detector.webgl) {
             $('div').remove();
             Detector.addGetWebGLMessage();
             throw new Error('Your browser does not seem to support WebGL');
         }
    };
    */
    function transformCorners(corners){
    	var j;
    	for (j = 0; j<corners.length;++j){
    		corners[j].x = corners[j].x - (canvas.width / 2);
          	corners[j].y = (canvas.height / 2) - corners[j].y;
    	}
    	return corners;
    }
            
            window.run = function run(generatedCode){
            	var openfunction, closefunction;
            	openfunction = "updateScene = function(markers) {"+
            	"var corners, corner, pose, i,k;"+
      			"for (i=0; i<markers.length; ++i){"/*+
        		"corners = transformCorners(markers[i].corners);"+
        		"pose = posit.pose(corners);"*/;
        		//updateObject(model, pose.bestRotation, pose.bestTranslation);
        		generatedCode=openfunction+generatedCode;

                closefunction = "}"+
                "texture.children[0].material.map.needsUpdate = true; };";
                generatedCode+=closefunction;
                
                console.log('generatedCode inside view iframe', generatedCode);
                eval(generatedCode);
           }
        //});
    </script>
</head>

<body>
	<video id="video" width=640 height=480 autoplay="true" style="display:none;"></video>
	<div style="width: 100%;">
    <div style="width: 650px; margin-left:auto; margin-right:auto;">
    <div class="invisible">
    	<canvas id="canvas" style="width: 640px; height: 480px; float: left; border: solid 1px black;"></canvas></div>
      <div id="container" style="width: 640px; height: 480px; float: left; border: solid 1px black; background: green;"></div>
      <!--div style="clear: both;"></div-->
    </div>
  </div>
</body>

</html>
