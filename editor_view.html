<!DOCTYPE html>
<HTML>
<script src="js/jquery/jquery-2.0.2.min.js"></script>
<script src='js/threejs/three.min.js'></script>
<script src="js/video/webrtc_adapter.js"></script>
<script src="js/video/streamvideo.js"></script>
<script src="js/skarf/skarf.min.js"></script>
<script src="js/js-aruco/svd.js"></script>
<script src="js/js-aruco/posit1.js"></script>
<script src="js/js-aruco/cv.js"></script>
<script src="js/js-aruco/aruco.js"></script>
<script type="text/javascript">
    var MARKER_SIZE = 35.0; //millimeters

        var clock = new THREE.Clock();
        var lookAtPoint = new THREE.Vector3();

        var isOrbiting = true;
        var canvas, canvasWidth, canvasHeight;
        var skarf, skarfJsArToolKit, skarfJsAruco;
        var trackingLibObjects = {};

        var trackingLibs = {
            'JSARToolKit': 'JSARToolKit',
            'js-aruco': 'js-aruco'
        };

        var options = {
            trackingLib: trackingLibs[Object.keys(trackingLibs)[0]],
            trackingSceneThreshold: 128,
            trackingSceneMultipleTrackers: false,
            cameraMotionAutoOrbit: false,
            cameraMotionRadius: 0.2,
            cameraMotionSpeed: 0.2,
            cameraMotionTiltAmp: 0.2,
            cameraMotionTiltOffset: 0.1,
            togglePauseOrbit: function () {
                isOrbiting = !isOrbiting;
            },
            displayRefCube: false,
            displayDebugView: false,
            displayOriginPlane: false,
            displayWireframe: false,
            displayLocalAxis: false
        };

        function checkWebGl() {
            if (!Detector.webgl) {
                $('div').remove();
                Detector.addGetWebGLMessage();
                throw new Error('Your browser does not seem to support WebGL');
            }
        }

        var vfov;
        var trackSceneRenderer, trackSceneScene, trackSceneCamera, trackSceneCameraControls;
        var trackScenePlaneMesh, trackScenePlaneMesh2, trackScenePlaneMesh3;
        var refCubeMesh, refCubeMesh2, refCubeMesh3;
        var composer;
        var source;




        var markerImages = {
            'JSARToolKit': [
            THREE.ImageUtils.loadTexture('markers/jsartoolkit/22.png'),
            THREE.ImageUtils.loadTexture('markers/jsartoolkit/81.png'),
            THREE.ImageUtils.loadTexture('markers/jsartoolkit/63.png')
        ],
            'js-aruco': [
            THREE.ImageUtils.loadTexture('markers/js-aruco/1001.png'),
            THREE.ImageUtils.loadTexture('markers/js-aruco/446.png'),
            THREE.ImageUtils.loadTexture('markers/js-aruco/923.png')
        ]
        }

        function setupThreejsTrackingScene() {

            //renderer
            trackSceneRenderer = new THREE.WebGLRenderer({
                antialias: true
            });
            trackSceneRenderer.setSize(canvasWidth, canvasHeight);
            trackSceneRenderer.setClearColor('#888888', 1);
            var $threejsTrackSceneContainerElem = $('#mainTracking3dScene div:eq(0)');
            $threejsTrackSceneContainerElem.after(trackSceneRenderer.domElement);
            source = trackSceneRenderer.domElement;

            //scene
            trackSceneScene = new THREE.Scene();

            //camera
            vfov = 40;
            trackSceneCamera = new THREE.PerspectiveCamera(vfov, canvasWidth / canvasHeight, 0.1, 1000);
            trackSceneCamera.position.set(0.25, 0.25, 0.25);
            trackSceneCamera.lookAt(new THREE.Vector3(0, 0, 0));
            trackSceneCameraControls = new THREE.OrbitControls(trackSceneCamera);
            trackSceneCameraControls.modifierKey = 'alt';

            //plane
            trackScenePlaneMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(0.1, 0.1, 2, 2),
                new THREE.MeshBasicMaterial()
            );
            trackScenePlaneMesh.geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
            trackSceneScene.add(trackScenePlaneMesh);

            //plane 2
            trackScenePlaneMesh2 = new THREE.Mesh(
                new THREE.PlaneGeometry(0.1, 0.1, 2, 2),
                new THREE.MeshBasicMaterial()
            );
            trackScenePlaneMesh2.geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
            trackScenePlaneMesh2.position.x = 0.11;
            trackScenePlaneMesh2.position.z = -0.07;
            trackSceneScene.add(trackScenePlaneMesh2);

            //plane 3
            trackScenePlaneMesh3 = new THREE.Mesh(
                new THREE.PlaneGeometry(0.1, 0.1, 2, 2),
                new THREE.MeshBasicMaterial()
            );
            trackScenePlaneMesh3.geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
            trackScenePlaneMesh3.position.x = -0.14;
            trackScenePlaneMesh3.position.z = -0.02;
            trackSceneScene.add(trackScenePlaneMesh3);

            //reference cube
            refCubeMesh = new THREE.Mesh(
                new THREE.CubeGeometry(0.1, 0.1, 0.1),
                new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    side: THREE.DoubleSide,
                    wireframe: true,
                    depthTest: false,
                    depthWrite: false
                })
            );
            refCubeMesh.position.y = 0.05;
            trackSceneScene.add(refCubeMesh);

            //reference cube 2
            refCubeMesh2 = new THREE.Mesh(
                new THREE.CubeGeometry(0.1, 0.1, 0.1),
                new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    side: THREE.DoubleSide,
                    wireframe: true,
                    depthTest: false,
                    depthWrite: false
                })
            );
            refCubeMesh2.position.x = trackScenePlaneMesh2.position.x;
            refCubeMesh2.position.y = 0.05;
            refCubeMesh2.position.z = trackScenePlaneMesh2.position.z;
            trackSceneScene.add(refCubeMesh2);

            //reference cube 3
            refCubeMesh3 = new THREE.Mesh(
                new THREE.CubeGeometry(0.1, 0.1, 0.1),
                new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    side: THREE.DoubleSide,
                    wireframe: true,
                    depthTest: false,
                    depthWrite: false
                })
            );
            refCubeMesh3.position.x = trackScenePlaneMesh3.position.x;
            refCubeMesh3.position.y = 0.05;
            refCubeMesh3.position.z = trackScenePlaneMesh3.position.z;
            trackSceneScene.add(refCubeMesh3);
        }

        var renderer, scene, cameraJsArToolKit, cameraJsAruco;
        var keyLight, fillLight;
        var materials = [];
        var originPlaneMesh;

        function setupMainScene() {

            //create renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(640, 360);
            renderer.setClearColor('#081419', 1);
            renderer.shadowMapEnabled = true;
            renderer.shadowMapType = THREE.PCFShadowMap;
            renderer.shadowMapSoft = true;
            var $threejsContainerElem = $('#threejs-container');
            $threejsContainerElem.append(renderer.domElement);

            //create scene
            scene = new THREE.Scene();

            //create cameras
            cameraJsArToolKit = new THREE.PerspectiveCamera(25, renderer.domElement.width / renderer.domElement.height, 0.1, 1000);
            cameraJsArToolKit.position.set(8, 8, 15);
            cameraJsArToolKit.lookAt(new THREE.Vector3(0, 0, 0));
            cameraJsArToolKit.matrixAutoUpdate = false;

            cameraJsAruco = new THREE.PerspectiveCamera(vfov, renderer.domElement.width / renderer.domElement.height, 0.1, 1000);
            cameraJsAruco.position.set(8, 8, 15);
            cameraJsAruco.lookAt(new THREE.Vector3(0, 0, 0));
            cameraJsAruco.matrixAutoUpdate = false;

            //create plane at origin
            var originPlaneGeom = new THREE.PlaneGeometry(MARKER_SIZE * 3, MARKER_SIZE * 3, 1, 1);
            originPlaneGeom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
            var originPlaneMaterial = new THREE.MeshPhongMaterial({
                color: 0x99ff66,
                side: THREE.DoubleSide,
                wireframe: false
            });
            materials.push(originPlaneMaterial);
            originPlaneMesh = new THREE.Mesh(originPlaneGeom, originPlaneMaterial);
            originPlaneMesh.castShadow = true;
            originPlaneMesh.receiveShadow = true;
            scene.add(originPlaneMesh);

            //setup lights
            scene.add(new THREE.AmbientLight(0x111111));

            keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
            keyLight.position.set(-50, 75, 75);
            keyLight.target.position.set(0, 0, 0);
            keyLight.castShadow = true;
            keyLight.shadowCameraNear = 60;
            keyLight.shadowCameraFar = 200;
            keyLight.shadowCameraRight = 150;
            keyLight.shadowCameraLeft = -150;
            keyLight.shadowCameraTop = 150;
            keyLight.shadowCameraBottom = -150;
            // keyLight.shadowCameraVisible = true;
            keyLight.shadowBias = 0.0001;
            keyLight.shadowDarkness = 0.5;
            keyLight.shadowMapWidth = 1024;
            keyLight.shadowMapHeight = 1024;
            scene.add(keyLight);

            fillLight = new THREE.DirectionalLight(0xffffff, 0.7);
            fillLight.position.set(25, 75, 75);
            fillLight.target.position.set(0, 0, 0);
            scene.add(fillLight);
        }

        function setupSkarf() {
            //INICIO VIDEO
            sourceVideoTrack = $('#mainVideo')[0];
            //FIN VIDEO  


            //create Skarf framework
            skarfJsArToolKit = new SKARF.Skarf({

                arLibType: 'jsartoolkit',
                trackingElem: sourceVideoTrack,
                markerSize: MARKER_SIZE,
                verticalFov: vfov,
                threshold: options.trackingSceneThreshold,
                debug: options.displayDebugView,

                canvasContainerElem: $('#canvas-container'),

                renderer: renderer,
                scene: scene,
                camera: cameraJsArToolKit,

                markersJsonFile: 'models/models_jsartoolkit.json'

            });
            trackingLibObjects['JSARToolKit'] = skarfJsArToolKit;

            skarfJsAruco = new SKARF.Skarf({

                arLibType: 'jsaruco',
                trackingElem: sourceVideoTrack,
                markerSize: MARKER_SIZE,
                verticalFov: vfov,
                debug: options.displayDebugView,

                canvasContainerElem: $('#canvas-container'),

                renderer: renderer,
                scene: scene,
                camera: cameraJsAruco,

                markersJsonFile: 'models/models_jsaruco.json'

            });
            trackingLibObjects['js-aruco'] = skarfJsAruco;

            skarf = trackingLibObjects[options.trackingLib];
        }
    
    var objects = [];
	var updateFcts	= []
	var scene	= new THREE.Scene()
	var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000 )
	camera.position.z = 4
    var hemiLight = new THREE.HemisphereLight( 0x0000ff, 0x00ff00, 0.6 ); 
    scene.add(hemiLight);
    
    //get canvas
    
    setupThreejsTrackingScene();
    setupMainScene();
    setupSkarf();
    setupVideo();
    streamVideo(video);
    render();
    
	// the function called to run the generatedCode
	window.run	= function run(generatedCode){
		console.log('generatedCode inside view iframe', generatedCode)
        console.log(objects.length);
        clearAll();
		eval(generatedCode)
        render();
	}

	//////////////////////////////////////////////////////////////////////////////////
	//		Camera Controls							//
	//////////////////////////////////////////////////////////////////////////////////
	var mouse	= {x : 0, y : 0}
	document.addEventListener('mousemove', function(event){
		mouse.x	= (event.clientX / window.innerWidth ) - 0.5
		mouse.y	= (event.clientY / window.innerHeight) - 0.5
	}, false)
	updateFcts.push(function(delta, now){
		camera.position.x += (mouse.x*5 - camera.position.x) * (delta*3)
		camera.position.y += (mouse.y*5 - camera.position.y+2) * (delta*3)
		camera.lookAt( scene.position )
	})

  function clearAll(){
    while(objects.length>0){
        console.log(scene.children)
        scene.removeObject(objects[0]);
        objects.shift();
    };
};
	//////////////////////////////////////////////////////////////////////////////////
	//		render the scene						//
	//////////////////////////////////////////////////////////////////////////////////
	updateFcts.push(function(){
		renderer.render( scene, camera );		
	})
    function render() {
            //update on every frame
            skarf.update(dt);
            renderer.render(scene, camera);
        }
	
	//////////////////////////////////////////////////////////////////////////////////
	//		loop runner							//
	//////////////////////////////////////////////////////////////////////////////////
	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		updateFcts.forEach(function(updateFn){
			updateFn(deltaMsec/1000, nowMsec/1000)
		})
	})
    
</script>
<body style='margin: 0px; background-color: #bbbbbb;overflow: hidden;'>
    <div class="container" id="threejs-container-parent">
        <div class="caption">three.js &lt;canvas&gt;</div>
        <div id="threejs-container"></div>
        <div class="caption">[ Alt+LMB: rotate ] [ Alt+MMB: pan ] [ Alt+RMB: zoom ]</div>
    </div>
    <div class="mainCanvas"></div>
    <div class="invisible" id="video-container">
        <video id="mainVideo" width="640" height="480" autoplay="autoplay" muted="true"></video>
    </div>
</body></HTML>
